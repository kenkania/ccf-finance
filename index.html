<html>
<style>
textarea {
    width: 800px;
    height: 400px;
    overflow-y: scroll;
    overflow: scroll;
    white-space: pre;
}
.button {
  background-color: #008cba; /* Green */
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  border-radius: 4px;
  user-select: none;
  cursor: pointer;
}
.error-box {
  display: none;
  background-color: #ffebee;
  border: 2px solid #ef5350;
  border-radius: 4px;
  padding: 15px;
  margin: 10px 0;
  color: #c62828;
  font-family: monospace;
  white-space: pre-wrap;
  max-width: 800px;
}
.error-box.visible {
  display: block;
}
</style>
<div>Enter Comma-delimited file content (goto the wells fargo account, then click "Download Account Activity", pick dates, and use Comma delimited):</div>
<textarea id="input"></textarea>
<br/>
<div id="submit" class="button">Transform</div>
<br/>
<div id="error" class="error-box"></div>
<div>Transformed content (copy this into CCF Transactions google sheet and then do "Data" -> "Split Text Into Columns"):</div>
<textarea id="output" readonly>
</textarea>
<script>
    const capitalize = (str, lower = true) =>
  (lower ? str.toLowerCase() : str).replace(/(?:^|\s|["'([{])+\S/g, match => match.toUpperCase());
;

    function parseZelle(tx) {
        var ref = tx.match(/REF # ?([a-zA-Z0-9]+)/)[1];
        var match = tx.match(/ ON \d\d\/\d\d REF # ?([a-zA-Z0-9]+)/);
        var rcvDate = "";
        // When the custom note is long, they may sacrifice the ON text.
        if (match == null) {
            match = tx.match(/ REF # ?([a-zA-Z0-9]+)/);
        } else {
            rcvDate = tx.match(/ ON (\d\d\/\d\d) REF #/)[1] + '/' + new Date().getFullYear();
        }
        var counterparty = capitalize(tx.substring("zelle  ".length + tx.match(/FROM|TO/)[0].length, match.index));
        
        var notes = tx.substring(match.index + match[0].length + 1).toLowerCase();

        return {
            method: "zelle",
            ref,
            rcvDate,
            notes,
            counterparty,
        };
    }

    function parseDescription(tx) {
        var lower = tx.toLowerCase();
        if (lower.startsWith("deposited or cashed check ") || lower.startsWith("check ")) {
            return {
                method: "check",
                ref: lower.split("check # ")[1],
            };
        } else if (lower.startsWith("zelle ")) {
            return parseZelle(tx);
        } else if (lower.startsWith("tithe.ly ")) {
            return {
                method: "tithely",
                ref: tx.substring("tithe.ly tithe.ly* ".length).split(" ")[0],
                counterparty: "PFP",
            };
        } else {
            throw new Error("unknown transaction type");
        }
    }
    
    function transformRow(cols) {
        const postDate = cols[0];
        const credit = cols[1].startsWith('-') ? "" : '$' + cols[1];
        const debit = cols[1].startsWith('-') ? '$' + cols[1].substring(1) : "";
        const custom = parseDescription(cols[4]);
        return [postDate, custom.rcvDate || "", custom.method, custom.ref, custom.counterparty || "TODO", credit, debit, custom.notes || ""];
    }
    function transform(csv) {
        var lines = csv.split('\r\n');
        if (lines.length == 1) {
            lines = csv.split('\n');
        }
        const values = lines
            .filter(s => s.length > 1)
            .map(row => row.substring(1, row.length - 1).split('","'))
            .map(transformRow)
            .sort((a, b) => new Date(a[0]) - new Date(b[0]));
        return values
            .map(row => row.map(s => '"' + s + '"').join(','))
            .join("\n");
    }
    
    function showError(message, lineNumber, lineText, error) {
        console.error("Transform error:", error);
        const errorBox = document.getElementById("error");
        errorBox.textContent = `Error on line ${lineNumber}:
${message}

Line content:
${lineText}`;
        errorBox.classList.add("visible");
    }
    
    function hideError() {
        const errorBox = document.getElementById("error");
        errorBox.classList.remove("visible");
    }
    
    window.onload = () => {
        document.getElementById("submit").addEventListener("click", () => {
            hideError();
            const input = document.getElementById("input").value;
            
            try {
                var lines = input.split('\r\n');
                if (lines.length == 1) {
                    lines = input.split('\n');
                }
                
                const filteredLines = lines.filter(s => s.length > 1);
                const parsedRows = [];
                
                for (let i = 0; i < filteredLines.length; i++) {
                    try {
                        const line = filteredLines[i];
                        const cols = line.substring(1, line.length - 1).split('","');
                        const transformed = transformRow(cols);
                        parsedRows.push(transformed);
                    } catch (err) {
                        showError(err.message, i + 1, filteredLines[i], err);
                        return;
                    }
                }
                
                const sorted = parsedRows.sort((a, b) => new Date(a[0]) - new Date(b[0]));
                const result = sorted
                    .map(row => row.map(s => '"' + s + '"').join(','))
                    .join("\n");
                
                document.getElementById("output").value = result;
            } catch (err) {
                console.error("Transform error:", err);
                showError(err.message, "unknown", "", err);
            }
        });
    };
</script>
</html>
